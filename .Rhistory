}, ignoreInit = TRUE)
})
})
# Função de resposta: tenta match exato; se não, tenta palavra-chave (grepl)
responder <- function(q, kb) {
if (is.null(q) || !nzchar(q)) return("")
chave <- tolower(trimws(q))
nomes <- names(kb)
# 1) Match exato
if (chave %in% tolower(nomes)) {
idx <- match(chave, tolower(nomes))
return(kb[[ idx ]])
}
# 2) Palavras-chave: retorna primeira que bater
for (k in nomes) {
if (grepl(k, chave, ignore.case = TRUE)) {
return(kb[[k]])
}
}
# 3) Fallback
"Desculpe, eu ainda não aprendi essa pergunta. Você pode me ensinar no painel ao lado."
}
# Enviar pergunta
observeEvent(input$enviar, {
req(input$pergunta)
user_msg <- input$pergunta
bot_msg  <- responder(user_msg, rv$kb)
rv$hist <- rbind(rv$hist,
data.frame(role = "user", text = user_msg, stringsAsFactors = FALSE),
data.frame(role = "bot",  text = bot_msg,  stringsAsFactors = FALSE))
updateTextInput(session, "pergunta", value = "")
})
# Ensinar nova pergunta/resposta
observeEvent(input$ensinar, {
q <- tolower(trimws(input$nova_q))
a <- trimws(input$nova_a)
validate(need(nzchar(q) && nzchar(a), "Preencha pergunta e resposta."))
rv$kb[[ q ]] <- a
rv$hist <- rbind(rv$hist,
data.frame(role = "bot", text = paste0("Aprendi algo novo: \"", q, "\"."), stringsAsFactors = FALSE))
updateTextInput(session, "nova_q", value = "")
updateTextAreaInput(session, "nova_a", value = "")
})
# Baixar conhecimento
output$baixar <- downloadHandler(
filename = function() paste0("conhecimento_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".json"),
content = function(file) {
write_json(rv$kb, path = file, auto_unbox = TRUE, pretty = TRUE)
}
)
# Subir conhecimento (substitui kb)
observeEvent(input$subir, {
req(input$subir$datapath)
novo <- tryCatch(read_json(input$subir$datapath, simplifyVector = TRUE), error = function(e) NULL)
validate(need(!is.null(novo) && is.list(novo), "Arquivo inválido. Envie um JSON no formato perguntas->respostas."))
rv$kb <- novo
rv$hist <- rbind(rv$hist, data.frame(role = "bot", text = "Conhecimento carregado do arquivo.", stringsAsFactors = FALSE))
})
# Resetar conhecimento
observeEvent(input$resetar, {
rv$kb <- conhecimento_inicial
rv$hist <- rbind(rv$hist, data.frame(role = "bot", text = "Conhecimento restaurado para o padrão.", stringsAsFactors = FALSE))
})
# Render do chat
output$chat <- renderUI({
if (nrow(rv$hist) == 0) return(tags$p(class="subtle", "Sem mensagens ainda."))
tagList(lapply(seq_len(nrow(rv$hist)), function(i) {
r <- rv$hist$role[i]
t <- rv$hist$text[i]
lado  <- if (r == "user") "right" else "left"
classe <- if (r == "user") "bubble user" else "bubble bot"
div(class = paste("msgrow", lado), div(class = classe, t))
}))
})
}
# -----------------------------
# Run app
# -----------------------------
shinyApp(ui, server)
# Mini IA em R renderizada em Shiny
# Salve este arquivo como app.R e rode com: shiny::runApp()
suppressPackageStartupMessages({
library(shiny)
library(jsonlite)
})
# -----------------------------
# "Cérebro" inicial (perguntas -> respostas)
# -----------------------------
conhecimento_inicial <- list(
"oi"                 = "Oi! Tudo bem? Eu sou uma mini IA feita em R (Shiny).",
"qual seu nome?"     = "Meu nome é MiniRBot!",
"o que voce faz?"    = "Eu respondo perguntas simples que aprendi e posso aprender novas.",
"tchau"              = "Até logo! Foi legal conversar com você.",
"campo pixel"        = "O CampoPixel transforma fotos em índices úteis para manejo agrícola."
)
# -----------------------------
# UI
# -----------------------------
ui <- fluidPage(
tags$head(tags$style(HTML('
body { background: #f7f7f9; }
.card { background:#fff; border-radius:18px; padding:18px; box-shadow:0 6px 18px rgba(0,0,0,.05); }
.bubble { max-width: 75%; padding:10px 14px; border-radius:16px; margin:6px 0; display:inline-block; }
.user   { background:#e8f0fe; align-self:flex-end; border-top-right-radius:6px; }
.bot    { background:#e9f7ef; align-self:flex-start; border-top-left-radius:6px; }
.chat   { display:flex; flex-direction:column; gap:6px; }
.msgrow { display:flex; }
.right  { justify-content:flex-end; }
.left   { justify-content:flex-start; }
.pill   { background:#eef2ff; border-radius:999px; padding:4px 10px; font-size:12px; margin-right:6px; cursor:pointer; display:inline-block; }
.title  { font-weight:700; font-size:20px; }
.subtle { color:#666; font-size:12px; }
.sep    { height:1px; background:#eee; margin:14px 0; }
.kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#f1f5f9; padding:2px 6px; border-radius:6px; }
'))),
titlePanel("Mini IA em R (Shiny)"),
fluidRow(
column(4,
div(class = "card",
div(class="title", "Pergunte"),
textInput("pergunta", NULL, placeholder = "Digite sua pergunta..."),
actionButton("enviar", "Enviar", class = "btn btn-primary"),
div(class="sep"),
div(class="subtle", "Sugestões:"),
uiOutput("sugestoes")
),
br(),
div(class = "card",
div(class="title", "Ensinar a IA"),
textInput("nova_q", "Pergunta que a IA deve reconhecer"),
textAreaInput("nova_a", "Resposta da IA", rows = 3),
actionButton("ensinar", "Adicionar ao cérebro", class = "btn btn-success"),
div(class="sep"),
div(class="subtle", "Exportar / Importar conhecimento"),
downloadButton("baixar", "Baixar conhecimento (.json)"),
br(), br(),
fileInput("subir", NULL, accept = ".json", buttonLabel = "Carregar .json"),
actionButton("resetar", "Restaurar conhecimento inicial", class = "btn btn-outline-secondary")
)
),
column(8,
div(class = "card",
div(class="title", "Chat"),
div(class="subtle", "Converse com a Mini IA. Dica: tente digitar \"oi\" ou \"o que voce faz?\""),
br(),
uiOutput("chat")
)
)
)
)
# -----------------------------
# SERVER
# -----------------------------
server <- function(input, output, session) {
rv <- reactiveValues(
# histórico: tibble-like data.frame com colunas role ("user"/"bot") e text
hist = data.frame(role = character(), text = character(), stringsAsFactors = FALSE),
# conhecimento atual
kb   = conhecimento_inicial
)
# Render sugestões de clique rápido
output$sugestoes <- renderUI({
sugs <- c("oi", "qual seu nome?", "o que voce faz?", "campo pixel", "tchau")
tags$div(
lapply(sugs, function(s) {
actionLink(inputId = paste0("sug_", gsub("[^a-z]", "_", s)), label = s, class = "pill")
})
)
})
# Observers das sugestões (gera dinamicamente)
observe({
sugs <- c("oi", "qual seu nome?", "o que voce faz?", "campo pixel", "tchau")
lapply(sugs, function(s) {
id <- paste0("sug_", gsub("[^a-z]", "_", s))
observeEvent(input[[id]], {
updateTextInput(session, "pergunta", value = s)
}, ignoreInit = TRUE)
})
})
# Função de resposta: tenta match exato; se não, tenta palavra-chave (grepl)
responder <- function(q, kb) {
if (is.null(q) || !nzchar(q)) return("")
chave <- tolower(trimws(q))
nomes <- names(kb)
# 1) Match exato
if (chave %in% tolower(nomes)) {
idx <- match(chave, tolower(nomes))
return(kb[[ idx ]])
}
# 2) Palavras-chave: retorna primeira que bater
for (k in nomes) {
if (grepl(k, chave, ignore.case = TRUE)) {
return(kb[[k]])
}
}
# 3) Fallback
"Desculpe, eu ainda não aprendi essa pergunta. Você pode me ensinar no painel ao lado."
}
# Enviar pergunta
observeEvent(input$enviar, {
req(input$pergunta)
user_msg <- input$pergunta
bot_msg  <- responder(user_msg, rv$kb)
rv$hist <- rbind(rv$hist,
data.frame(role = "user", text = user_msg, stringsAsFactors = FALSE),
data.frame(role = "bot",  text = bot_msg,  stringsAsFactors = FALSE))
updateTextInput(session, "pergunta", value = "")
})
# Ensinar nova pergunta/resposta
observeEvent(input$ensinar, {
q <- tolower(trimws(input$nova_q))
a <- trimws(input$nova_a)
validate(need(nzchar(q) && nzchar(a), "Preencha pergunta e resposta."))
rv$kb[[ q ]] <- a
rv$hist <- rbind(rv$hist,
data.frame(role = "bot", text = paste0("Aprendi algo novo: \"", q, "\"."), stringsAsFactors = FALSE))
updateTextInput(session, "nova_q", value = "")
updateTextAreaInput(session, "nova_a", value = "")
})
# Baixar conhecimento
output$baixar <- downloadHandler(
filename = function() paste0("conhecimento_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".json"),
content = function(file) {
write_json(rv$kb, path = file, auto_unbox = TRUE, pretty = TRUE)
}
)
# Subir conhecimento (substitui kb)
observeEvent(input$subir, {
req(input$subir$datapath)
novo <- tryCatch(read_json(input$subir$datapath, simplifyVector = TRUE), error = function(e) NULL)
validate(need(!is.null(novo) && is.list(novo), "Arquivo inválido. Envie um JSON no formato perguntas->respostas."))
rv$kb <- novo
rv$hist <- rbind(rv$hist, data.frame(role = "bot", text = "Conhecimento carregado do arquivo.", stringsAsFactors = FALSE))
})
# Resetar conhecimento
observeEvent(input$resetar, {
rv$kb <- conhecimento_inicial
rv$hist <- rbind(rv$hist, data.frame(role = "bot", text = "Conhecimento restaurado para o padrão.", stringsAsFactors = FALSE))
})
# Render do chat
output$chat <- renderUI({
if (nrow(rv$hist) == 0) return(tags$p(class="subtle", "Sem mensagens ainda."))
tagList(lapply(seq_len(nrow(rv$hist)), function(i) {
r <- rv$hist$role[i]
t <- rv$hist$text[i]
lado  <- if (r == "user") "right" else "left"
classe <- if (r == "user") "bubble user" else "bubble bot"
div(class = paste("msgrow", lado), div(class = classe, t))
}))
})
}
# -----------------------------
# Run app
# -----------------------------
shinyApp(ui, server)
# Mini IA em R renderizada em Shiny
# Salve este arquivo como app.R e rode com: shiny::runApp()
suppressPackageStartupMessages({
library(shiny)
library(jsonlite)
})
# -----------------------------
# "Cérebro" inicial (perguntas -> respostas)
# -----------------------------
conhecimento_inicial <- list(
"oi"                 = "Oi! Tudo bem? Eu sou uma mini IA feita em R (Shiny).",
"qual seu nome?"     = "Meu nome é MiniRBot!",
"o que voce faz?"    = "Eu respondo perguntas simples que aprendi e posso aprender novas.",
"tchau"              = "Até logo! Foi legal conversar com você.",
"campo pixel"        = "O CampoPixel transforma fotos em índices úteis para manejo agrícola."
)
# -----------------------------
# UI
# -----------------------------
ui <- fluidPage(
tags$head(tags$style(HTML('
body { background: #f7f7f9; }
.card { background:#fff; border-radius:18px; padding:18px; box-shadow:0 6px 18px rgba(0,0,0,.05); }
.bubble { max-width: 75%; padding:10px 14px; border-radius:16px; margin:6px 0; display:inline-block; }
.user   { background:#e8f0fe; align-self:flex-end; border-top-right-radius:6px; }
.bot    { background:#e9f7ef; align-self:flex-start; border-top-left-radius:6px; }
.chat   { display:flex; flex-direction:column; gap:6px; }
.msgrow { display:flex; }
.right  { justify-content:flex-end; }
.left   { justify-content:flex-start; }
.pill   { background:#eef2ff; border-radius:999px; padding:4px 10px; font-size:12px; margin-right:6px; cursor:pointer; display:inline-block; }
.title  { font-weight:700; font-size:20px; }
.subtle { color:#666; font-size:12px; }
.sep    { height:1px; background:#eee; margin:14px 0; }
.kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#f1f5f9; padding:2px 6px; border-radius:6px; }
'))),
titlePanel("Mini IA em R (Shiny)"),
fluidRow(
column(4,
div(class = "card",
div(class="title", "Pergunte"),
textInput("pergunta", NULL, placeholder = "Digite sua pergunta..."),
actionButton("enviar", "Enviar", class = "btn btn-primary"),
div(class="sep"),
div(class="subtle", "Sugestões:"),
uiOutput("sugestoes")
),
br(),
div(class = "card",
div(class="title", "Ensinar a IA"),
textInput("nova_q", "Pergunta que a IA deve reconhecer"),
textAreaInput("nova_a", "Resposta da IA", rows = 3),
actionButton("ensinar", "Adicionar ao cérebro", class = "btn btn-success"),
div(class="sep"),
div(class="subtle", "Exportar / Importar conhecimento"),
downloadButton("baixar", "Baixar conhecimento (.json)"),
br(), br(),
fileInput("subir", NULL, accept = ".json", buttonLabel = "Carregar .json"),
actionButton("resetar", "Restaurar conhecimento inicial", class = "btn btn-outline-secondary")
)
),
column(8,
div(class = "card",
div(class="title", "Chat"),
div(class="subtle", "Converse com a Mini IA. Dica: tente digitar \"oi\" ou \"o que voce faz?\""),
br(),
uiOutput("chat")
)
)
)
)
# -----------------------------
# SERVER
# -----------------------------
server <- function(input, output, session) {
rv <- reactiveValues(
# histórico: tibble-like data.frame com colunas role ("user"/"bot") e text
hist = data.frame(role = character(), text = character(), stringsAsFactors = FALSE),
# conhecimento atual
kb   = conhecimento_inicial
)
# Render sugestões de clique rápido
output$sugestoes <- renderUI({
sugs <- c("oi", "qual seu nome?", "o que voce faz?", "campo pixel", "tchau")
tags$div(
lapply(sugs, function(s) {
actionLink(inputId = paste0("sug_", gsub("[^a-z]", "_", s)), label = s, class = "pill")
})
)
})
# Observers das sugestões (gera dinamicamente)
observe({
sugs <- c("oi", "qual seu nome?", "o que voce faz?", "campo pixel", "tchau")
lapply(sugs, function(s) {
id <- paste0("sug_", gsub("[^a-z]", "_", s))
observeEvent(input[[id]], {
updateTextInput(session, "pergunta", value = s)
}, ignoreInit = TRUE)
})
})
# Função de resposta: tenta match exato; se não, tenta palavra-chave (grepl)
responder <- function(q, kb) {
if (is.null(q) || !nzchar(q)) return("")
chave <- tolower(trimws(q))
nomes <- names(kb)
# 1) Match exato
if (chave %in% tolower(nomes)) {
idx <- match(chave, tolower(nomes))
return(kb[[ idx ]])
}
# 2) Palavras-chave: retorna primeira que bater
for (k in nomes) {
if (grepl(k, chave, ignore.case = TRUE)) {
return(kb[[k]])
}
}
# 3) Fallback
"Desculpe, eu ainda não aprendi essa pergunta. Você pode me ensinar no painel ao lado."
}
# Enviar pergunta
observeEvent(input$enviar, {
req(input$pergunta)
user_msg <- input$pergunta
bot_msg  <- responder(user_msg, rv$kb)
rv$hist <- rbind(rv$hist,
data.frame(role = "user", text = user_msg, stringsAsFactors = FALSE),
data.frame(role = "bot",  text = bot_msg,  stringsAsFactors = FALSE))
updateTextInput(session, "pergunta", value = "")
})
# Ensinar nova pergunta/resposta
observeEvent(input$ensinar, {
q <- tolower(trimws(input$nova_q))
a <- trimws(input$nova_a)
validate(need(nzchar(q) && nzchar(a), "Preencha pergunta e resposta."))
rv$kb[[ q ]] <- a
rv$hist <- rbind(rv$hist,
data.frame(role = "bot", text = paste0("Aprendi algo novo: \"", q, "\"."), stringsAsFactors = FALSE))
updateTextInput(session, "nova_q", value = "")
updateTextAreaInput(session, "nova_a", value = "")
})
# Baixar conhecimento
output$baixar <- downloadHandler(
filename = function() paste0("conhecimento_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".json"),
content = function(file) {
write_json(rv$kb, path = file, auto_unbox = TRUE, pretty = TRUE)
}
)
# Subir conhecimento (substitui kb)
observeEvent(input$subir, {
req(input$subir$datapath)
novo <- tryCatch(read_json(input$subir$datapath, simplifyVector = TRUE), error = function(e) NULL)
validate(need(!is.null(novo) && is.list(novo), "Arquivo inválido. Envie um JSON no formato perguntas->respostas."))
rv$kb <- novo
rv$hist <- rbind(rv$hist, data.frame(role = "bot", text = "Conhecimento carregado do arquivo.", stringsAsFactors = FALSE))
})
# Resetar conhecimento
observeEvent(input$resetar, {
rv$kb <- conhecimento_inicial
rv$hist <- rbind(rv$hist, data.frame(role = "bot", text = "Conhecimento restaurado para o padrão.", stringsAsFactors = FALSE))
})
# Render do chat
output$chat <- renderUI({
if (nrow(rv$hist) == 0) return(tags$p(class="subtle", "Sem mensagens ainda."))
tagList(lapply(seq_len(nrow(rv$hist)), function(i) {
r <- rv$hist$role[i]
t <- rv$hist$text[i]
lado  <- if (r == "user") "right" else "left"
classe <- if (r == "user") "bubble user" else "bubble bot"
div(class = paste("msgrow", lado), div(class = classe, t))
}))
})
}
# -----------------------------
# Run app
# -----------------------------
shinyApp(ui, server)
library(caagro)
anIC(iniciar = TRUE)
anQuant(iniciar = TRUE)
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
anIC(iniciar = TRUE)
runApp('inst/shiny/anIC')
runApp('inst/shiny/anIC')
runApp('inst/shiny/anIC')
runApp('inst/shiny/anIC')
runApp('inst/shiny/anIC')
runApp('inst/shiny/anIC')
runApp('inst/shiny/anIC')
runApp('inst/shiny/anQuali')
runApp('inst/shiny/anQuali')
runApp('inst/shiny/anQuali')
runApp('inst/shiny/anQuali')
runApp('inst/shiny/anQuali')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
rm(list = ls())
gc()   # força a coleta de lixo para liberar memória
install.packages("remotes")
remotes::install_github("wilhanvalasco/caagro")
library(caagro)
anIC(iniciar = TRUE)
anIC(iniciar = TRUE)
anIC(iniciar = TRUE)
anQuant(iniciar = TRUE)
shiny::runApp('inst/shiny/anQuali')
runApp('inst/shiny/anQuali')
runApp('inst/shiny/anQuali')
system("git config --list --show-origin")
git push origin nome_da_branch
remotes::install_github("wilhanvalasco/caagro")
library(caagro)
anQuant(iniciar = TRUE)
remotes::install_github("wilhanvalasco/caagro")
devtools::document()
remotes::install_github("wilhanvalasco/caagro@v0.1.1")
anQuant(iniciar = TRUE)
library(caagro)
anQuant(iniciar = TRUE)
runApp('inst/shiny/anQuant')
runApp('inst/shiny/anQuant')
# Gera/atualiza Rd em man/, NAMESPACE etc.
devtools::document()
devtools::check()
install.packages("rcmdcheck")
install.packages("rcmdcheck")
rcmdcheck::rcmdcheck(error_on = "never") -> chk
chk$errors      # leia a(s) mensagem(ns) de erro
devtools::check()
